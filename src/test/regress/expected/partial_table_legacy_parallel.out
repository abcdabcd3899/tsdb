-- TODO: inherit tables
-- TODO: partition tables
-- TODO: ao tables
-- TODO: tables and temp tables
\set explain 'explain analyze'
create extension if not exists gp_debug_numsegments;
NOTICE:  extension "gp_debug_numsegments" already exists, skipping
drop schema if exists test_partial_table;
NOTICE:  schema "test_partial_table" does not exist, skipping
create schema test_partial_table;
set search_path=test_partial_table,public;
set allow_system_table_mods=true;
--
-- prepare kinds of tables
--
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t1 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d1 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r1 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t2 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d2 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r2 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in (
		't1'::regclass, 'd1'::regclass, 'r1'::regclass,
		't2'::regclass, 'd2'::regclass, 'r2'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t1       | 1 2     | p          |           1
 d1       |         | r          |           1
 r1       |         | p          |           1
 t2       | 1 2     | p          |           2
 d2       |         | r          |           2
 r2       |         | p          |           2
(6 rows)

analyze t1;
analyze d1;
analyze r1;
analyze t2;
analyze d2;
analyze r2;
--
-- regression tests
--
-- Test numsegments properity cannot be larger than the size of cluster
create table size_sanity_check(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
update gp_distribution_policy set numsegments = 10 where localoid = 'size_sanity_check'::regclass;
select * from size_sanity_check;
ERROR:  cannot access table "size_sanity_check" in current transaction
LINE 1: select * from size_sanity_check;
                      ^
DETAIL:  New segments are concurrently added to the cluster during the execution of current transaction, the table has data on some of the new segments, but these new segments are invisible and inaccessible to current transaction.
HINT:  Re-run the query in a new transaction.
update gp_distribution_policy set numsegments = 3 where localoid = 'size_sanity_check'::regclass;
-- a temp table is created during reorganization, its numsegments should be
-- the same with original table, otherwise some data will be lost after the
-- reorganization.
--
-- in most cases the temp table is created with CTAS.
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

abort;
-- but there are also cases the temp table is created with CREATE + INSERT.
-- case 1: with dropped columns
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	alter table t1 drop column c4;
	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 
---------------+----+----+----
             0 |  1 |  1 |   
             0 |  2 |  2 |   
             0 |  3 |  3 |   
             0 |  4 |  4 |   
             0 |  5 |  5 |   
             0 |  6 |  6 |   
             0 |  7 |  7 |   
             0 |  8 |  8 |   
             0 |  9 |  9 |   
             0 | 10 | 10 |   
(10 rows)

abort;
-- case 2: AOCO
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=column)
	  distributed by (c1, c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- case 3: AO + index
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=row)
	  distributed by (c1, c2);
	create index ti on t (c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- restore the analyze information
analyze t1;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- append SingleQE of different sizes
select max(c1) as v, 1 as r from t2 union all select 1 as v, 2 as r;
 v | r 
---+---
   | 1
 1 | 2
(2 rows)

-- append node should use the max numsegments of all the subpaths
begin;
	-- insert enough data to ensure executors got reached on segments
	insert into t1 select i from generate_series(1,100) i;
	insert into t2 select i from generate_series(1,100) i;
	:explain  select * from t2 a join t2 b using(c2)
	union all select * from t1 c join t1 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..4.39 rows=10 width=28) (actual time=2.729..2.729 rows=0 loops=1)
   ->  Append  (cost=1.04..4.24 rows=5 width=28) (actual time=2.276..2.276 rows=0 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.378..1.380 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: a.c2
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.042 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.053..0.053 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.015..0.036 rows=100 loops=1)
                           Hash Key: b.c2
                           ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.041 rows=52 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.896..0.896 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Seq Scan on t1 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.040..0.041 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.031 rows=100 loops=1)
 Planning Time: 0.563 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2085K bytes avg x 2 workers, 2087K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 16K bytes avg x 2 workers, 16K bytes max (seg0).
   (slice3)    Executor memory: 16K bytes avg x 2 workers, 16K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 21.188 ms
(26 rows)

	:explain  select * from t1 a join t1 b using(c2)
	union all select * from t2 c join t2 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..4.39 rows=10 width=28) (actual time=1.872..1.873 rows=0 loops=1)
   ->  Append  (cost=1.02..4.24 rows=5 width=28) (actual time=1.409..1.409 rows=0 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.286..0.287 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.062..0.062 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.049 rows=100 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.121..1.121 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: c.c2
                     ->  Seq Scan on t2 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.029 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.926..0.926 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.875..0.909 rows=100 loops=1)
                           Hash Key: d.c2
                           ->  Seq Scan on t2 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.034 rows=52 loops=1)
 Planning Time: 0.384 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2086K bytes avg x 2 workers, 2088K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.428 ms
(26 rows)

abort;
-- partitioned table should have the same numsegments for parent and children
-- even in RANDOM mode.
select gp_debug_set_create_table_default_numsegments('random');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 RANDOM
(1 row)

begin;
	create table t (c1 int, c2 int) distributed by (c1)
	partition by range(c2) (start(0) end(20) every(1));
	-- verify that parent and children have the same numsegments
	select count(a.localoid)
	  from gp_distribution_policy a
	  join pg_class c
	    on a.localoid = c.oid
	   and c.relname like 't_1_prt_%'
	  join gp_distribution_policy b
	    on a.numsegments = b.numsegments
	   and b.localoid = 't'::regclass
	;
 count 
-------
    20
(1 row)

abort;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- verify numsegments in subplans
:explain select * from t1, t2
   where t1.c1 > any (select max(t2.c1) from t2 where t2.c2 = t1.c2)
     and t2.c1 > any (select max(t1.c1) from t1 where t1.c2 = t2.c2);
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000002.12 rows=3 width=32) (actual time=0.694..0.694 rows=0 loops=1)
   ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=32) (actual time=0.046..0.047 rows=0 loops=1)
         ->  Seq Scan on t1  (cost=0.00..1.01 rows=1 width=16) (actual time=0.043..0.043 rows=0 loops=1)
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                       ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                             Filter: (t2_1.c2 = t1.c2)
                             ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                   ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                         ->  Seq Scan on t2 t2_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Materialize  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     ->  Seq Scan on t2  (cost=0.00..1.01 rows=1 width=16) (actual time=0.067..0.067 rows=0 loops=1)
                           Filter: (SubPlan 2)
                           SubPlan 2
                             ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                                   ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                                         Filter: (t1_1.c2 = t2.c2)
                                         ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                               ->  Broadcast Motion 1:2  (slice4; segments: 1)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                                     ->  Seq Scan on t1 t1_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.052..0.053 rows=0 loops=1)
 Planning Time: 0.282 ms
   (slice0)    Executor memory: 83K bytes.
   (slice1)    Executor memory: 35K bytes (seg0).
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 16K bytes max (seg0).
   (slice3)    Executor memory: 28K bytes avg x 2 workers, 28K bytes max (seg0).
   (slice4)    Executor memory: 16K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 29.895 ms
(31 rows)

--
-- It is used to test this case:
--   A: replicated table, distributed on 2 segments
--   B: replicated table, distributed on 1 segments
--   UPDATE A SET XXX FROM B WHERE XXX;
-- We have to add a broadcast motion on B so that A can update/delete correctly.
--
begin;
    insert into d1 select i,i,i,i from generate_series(1,2) i;
    insert into d2 select i,i,i,i from generate_series(1,3) i;
    explain update d2 a set c3=b.c3 from d1 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice1; segments: 2)  (cost=10000000002.06..10000000002.06 rows=3 width=44)
   ->  Update on d2 a  (cost=10000000000.00..10000000002.06 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=44)
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Materialize  (cost=0.00..1.03 rows=1 width=22)
                     ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=22)
                           ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(8 rows)

    update d2 a set c3=b.c3 from d1 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
  3 |  3 |  1 |  3 |  1 |  1 |  1 |  1
(3 rows)

    explain update d1 a set c3=b.c3 from d2 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000002.03..10000000002.03 rows=3 width=44)
   ->  Update on d1 a  (cost=10000000000.00..10000000002.03 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.03 rows=3 width=44)
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(6 rows)

    update d1 a set c3=b.c3 from d2 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
(2 rows)

abort;
-- restore the analyze information
analyze d1;
analyze d2;
--
-- create table: LIKE, INHERITS and DISTRIBUTED BY
--
-- tables are always created with DEFAULT as numsegments,
-- no matter there is LIKE, INHERITS or DISTRIBUTED BY.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

-- none of the clauses
create table t ();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY only
create table t () distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS only
create table t () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- LIKE only
create table t (like d1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS
create table t () inherits (t2) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + LIKE
create table t (like d1) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS + LIKE
create table t (like d1) inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS + LIKE
create table t (like d1) inherits (t2) distributed randomly;
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS from multiple parents
create table t () inherits (r1, t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS from multiple parents
create table t () inherits (r1, t2) distributed by (c1);
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1       | p          |           2
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- CTAS set numsegments with DEFAULT,
-- let it be a fixed value to get stable output
select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

create table t as table t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           3
(1 row)

drop table t;
select * into table t from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

--
-- alter table
--
-- numsegments should not be changed
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t (like t1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t set distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           1
(1 row)

alter table t set distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           1
(1 row)

alter table t set distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t add column c10 int;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t alter column c10 type text;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- below join cases cover all the combinations of
--
--     select * from {t,d,r}{1,2} a
--      {left,} join {t,d,r}{1,2} b
--      using (c1{',c2',});
--
-- there might be some duplicated ones, like 't1 join d1' and 'd1 join t1',
-- or 'd1 join r1 using (c1)' and 'd1 join r1 using (c1, c2)', this is because
-- we generate them via scripts and do not clean them up manually.
--
-- please do not remove the duplicated ones as we care about the motion
-- direction of different join orders, e.g. 't2 join t1' and 't1 join t2'
-- should both distribute t2 to t1.
--
-- JOIN
--
-- x1 join y1
:explain select * from t1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.229..0.229 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.137 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.466 ms
(12 rows)

:explain select * from t1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.146..0.146 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.138 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.360 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.214..0.214 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.119 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.449 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.212..0.212 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.254 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.557 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=1.969..1.969 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.381 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 63.316 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.899..1.900 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.003..0.004 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.287 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.813 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.677..0.677 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.419 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.317 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.177..0.178 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.006..0.007 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.510 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.798 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.153..0.153 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.005..0.005 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.295 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.587 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.140..0.140 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.005..0.005 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.411 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.651 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.137..0.138 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.005..0.005 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.165 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.355 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.144..0.145 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.161 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.352 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.885..0.885 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.144 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.391 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.479..1.479 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.002..0.002 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.482 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.446 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.773..0.773 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.015 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.178 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.188 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.332..0.333 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.011..0.012 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.167 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.611 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.769..0.769 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=28) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.168 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 62K bytes avg x 2 workers, 62K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.376 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.931..1.932 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.528 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 65K bytes avg x 2 workers, 65K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.949 ms
(12 rows)

-- x1 join y2
:explain select * from t1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=3.919..3.919 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=3.030..3.030 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.040..0.040 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.023..0.024 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
 Planning Time: 0.595 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.665 ms
(15 rows)

:explain select * from t1 a join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=3.368..3.369 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=2.353..2.354 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.044..0.044 rows=0 loops=1)
 Planning Time: 0.598 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.059 ms
(16 rows)

:explain select * from t1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.352..0.352 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.020..0.020 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.306 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.857 ms
(12 rows)

:explain select * from t1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.321..0.322 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.017..0.018 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.357 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.812 ms
(12 rows)

:explain select * from t1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.014..1.014 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.664..0.665 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
 Planning Time: 0.422 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.501 ms
(15 rows)

:explain select * from t1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.939..0.939 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.589..0.590 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.020 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
 Planning Time: 0.354 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.167 ms
(16 rows)

:explain select * from d1 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=0.910..0.910 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.525..0.526 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.032..0.032 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.435 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 16K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 14.348 ms
(19 rows)

:explain select * from d1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.571..1.572 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.514..0.514 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.035..0.036 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
 Planning Time: 0.522 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.151 ms
(16 rows)

:explain select * from d1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.344..0.344 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.283 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.837 ms
(12 rows)

:explain select * from d1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.337..0.337 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.340 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.835 ms
(12 rows)

:explain select * from d1 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.887..1.887 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.496..1.497 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.063..1.063 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.062..1.062 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.291 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.501 ms
(19 rows)

:explain select * from d1 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.768..1.768 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.362..1.363 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.910..0.911 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.909..0.909 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.359 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 14K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.377 ms
(19 rows)

:explain select * from r1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.648..0.649 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.244..0.245 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
 Planning Time: 0.524 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.381 ms
(15 rows)

:explain select * from r1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.008..1.009 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.325..0.325 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.015 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.014..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.564 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.559 ms
(16 rows)

:explain select * from r1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.389..0.389 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.313 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.834 ms
(12 rows)

:explain select * from r1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.303..0.303 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.371 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.744 ms
(12 rows)

:explain select * from r1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.891..0.891 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.435..0.436 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.249 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.202 ms
(15 rows)

:explain select * from r1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.909..0.909 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.414..0.414 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.289 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.234 ms
(15 rows)

-- x2 join y1
:explain select * from t2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.906..0.906 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.474..0.475 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.025..0.026 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.024 rows=0 loops=1)
 Planning Time: 0.459 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.521 ms
(15 rows)

:explain select * from t2 a join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.906..1.906 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=1.395..1.396 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.947..0.947 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.946..0.946 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
 Planning Time: 0.506 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.512 ms
(16 rows)

:explain select * from t2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.034..1.034 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.454..0.455 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
 Planning Time: 0.436 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.246 ms
(19 rows)

:explain select * from t2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.098..1.098 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.479..0.479 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.021 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.020 rows=0 loops=1)
 Planning Time: 0.484 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.691 ms
(16 rows)

:explain select * from t2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.844..0.844 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.456..0.456 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.436 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.075 ms
(15 rows)

:explain select * from t2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.050..1.051 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.472..0.473 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.707 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.186 ms
(16 rows)

:explain select * from d2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.413..0.414 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.015 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.299 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.909 ms
(12 rows)

:explain select * from d2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.350..0.350 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.288 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.801 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.451..0.451 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.308 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.001 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.352..0.352 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.353 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.868 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.364..0.364 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.371 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.863 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.410..0.411 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.012..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.435 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.886 ms
(12 rows)

:explain select * from r2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.039..1.039 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.614..0.615 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.025..0.026 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.024 rows=0 loops=1)
 Planning Time: 0.211 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.106 ms
(15 rows)

:explain select * from r2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.979..0.979 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.586..0.586 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.277 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.050 ms
(16 rows)

:explain select * from r2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.855..0.855 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.477..0.478 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.215 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.058 ms
(19 rows)

:explain select * from r2 a join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.570..1.571 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.064..1.064 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.609..0.609 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.608..0.608 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.285 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.090 ms
(19 rows)

:explain select * from r2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.853..0.853 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.465..0.466 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.309 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.037 ms
(15 rows)

:explain select * from r2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.838..0.838 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.466..0.467 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.352 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.016 ms
(15 rows)

-- x2 join y2
:explain select * from t2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=6.116..6.117 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=1 width=28) (actual time=4.451..4.456 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.016..0.018 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 4:4  (slice3; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.014..0.015 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.481 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 107.672 ms
(19 rows)

:explain select * from t2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.02..2.10 rows=3 width=24) (actual time=1.994..1.994 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=1 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.288 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 4 workers, 64K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.770 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.597..0.597 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes avg x 2 workers, 19K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.910 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.378..0.378 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.236 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes avg x 2 workers, 23K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.724 ms
(12 rows)

:explain select * from t2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=3.328..3.328 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=1 width=28) (actual time=2.994..2.997 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.228 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 54.310 ms
(19 rows)

:explain select * from t2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.823..1.823 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.786..0.787 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.552 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.639 ms
(16 rows)

:explain select * from d2 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.266..0.266 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.188 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.548 ms
(12 rows)

:explain select * from d2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.237..0.237 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.497 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.209..0.209 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.117 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.447 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.200..0.200 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.140 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.424 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.303..0.303 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.110 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.545 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.224..0.224 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.175 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.508 ms
(12 rows)

:explain select * from r2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=3.355..3.356 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=1 width=28) (actual time=1.743..1.743 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.253 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 54.385 ms
(19 rows)

:explain select * from r2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.682..1.682 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.727..0.728 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.588 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.461 ms
(16 rows)

:explain select * from r2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.364..0.364 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.023..0.023 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.282 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.911 ms
(12 rows)

:explain select * from r2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.186..0.186 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.335 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.699 ms
(12 rows)

:explain select * from r2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.267..1.267 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.022..1.023 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.533..0.534 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.533..0.533 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.342 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.071 ms
(19 rows)

:explain select * from r2 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=0.724..0.724 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.10 rows=2 width=24) (actual time=0.487..0.487 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
 Planning Time: 0.405 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.967 ms
(19 rows)

-- x1 left join y1
:explain select * from t1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.188..0.188 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.205 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.505 ms
(12 rows)

:explain select * from t1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.166..0.166 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.544 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.633 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.142..0.143 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.008..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.260 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.543 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.139..0.139 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.312 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.515 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.195..0.195 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.330 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.534 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.151..0.151 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.380 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.547 ms
(12 rows)

:explain select * from d1 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.871..1.872 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.664..1.664 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.867..0.867 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.036..0.037 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.289..0.290 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.289..0.289 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.058..0.058 rows=0 loops=1)
 Planning Time: 0.296 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.357 ms
(19 rows)

:explain select * from d1 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.754..0.754 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.497..0.498 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.201 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.081 ms
(16 rows)

:explain select * from d1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.280..0.280 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.146 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.572 ms
(12 rows)

:explain select * from d1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.285..0.285 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.174 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.566 ms
(12 rows)

:explain select * from d1 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.060..1.061 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.779..0.779 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.338..0.339 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.338..0.338 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
 Planning Time: 0.219 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.435 ms
(19 rows)

:explain select * from d1 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=0.656..0.656 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=0.443..0.443 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.130..0.130 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.130..0.130 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.266 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.995 ms
(19 rows)

:explain select * from r1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.988..0.988 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.003..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.181 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.772 ms
(12 rows)

:explain select * from r1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.754..1.754 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.003..0.003 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.531 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.616 ms
(12 rows)

:explain select * from r1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=1.462..1.462 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.732..0.732 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.011..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.325 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.950 ms
(13 rows)

:explain select * from r1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=1.044..1.044 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.681..0.682 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.447 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.579 ms
(13 rows)

:explain select * from r1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.775..0.775 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=28) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.209 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 62K bytes avg x 2 workers, 62K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.558 ms
(12 rows)

:explain select * from r1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.888..1.888 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.597 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 65K bytes avg x 2 workers, 65K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.878 ms
(12 rows)

-- x1 left join y2
:explain select * from t1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.824..1.824 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.612..0.613 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.432 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.415 ms
(15 rows)

:explain select * from t1 a left join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.547..1.548 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.08 rows=2 width=24) (actual time=1.194..1.194 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.627..0.628 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.626..0.627 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
 Planning Time: 0.459 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.134 ms
(16 rows)

:explain select * from t1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.320..0.320 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.015 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.264 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.731 ms
(12 rows)

:explain select * from t1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.209..0.209 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.228 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.511 ms
(12 rows)

:explain select * from t1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.817..0.817 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.464..0.464 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.197 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.855 ms
(15 rows)

:explain select * from t1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.629..0.629 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.419..0.419 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.257 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.814 ms
(16 rows)

:explain select * from d1 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.454..1.454 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.252..1.252 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.825..0.825 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.117..0.117 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.116..0.116 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.308 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.895 ms
(19 rows)

:explain select * from d1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.933..0.933 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.368..0.368 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.124..0.124 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
 Planning Time: 0.320 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.343 ms
(16 rows)

:explain select * from d1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.189..0.190 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.171 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.472 ms
(12 rows)

:explain select * from d1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.240..0.240 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.207 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.544 ms
(12 rows)

:explain select * from d1 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.506..0.506 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.322..0.322 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.078..0.078 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
 Planning Time: 0.192 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.929 ms
(19 rows)

:explain select * from d1 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.624..1.624 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.321..1.321 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.125..0.125 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.950..0.950 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.949..0.949 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.244 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 14K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.061 ms
(19 rows)

:explain select * from r1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.424..0.424 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.213..0.213 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
 Planning Time: 0.329 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.943 ms
(15 rows)

:explain select * from r1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.100..1.100 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.426..0.426 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.213..0.213 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.307 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.474 ms
(16 rows)

:explain select * from r1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.370..0.370 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.202..0.203 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
 Planning Time: 0.177 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.622 ms
(13 rows)

:explain select * from r1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.379..0.380 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.210..0.211 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
 Planning Time: 0.207 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.623 ms
(13 rows)

:explain select * from r1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.366..0.366 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.199..0.200 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
 Planning Time: 0.193 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.853 ms
(15 rows)

:explain select * from r1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.380..0.381 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.201..0.201 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
 Planning Time: 0.232 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.821 ms
(15 rows)

-- x2 left join y1
:explain select * from t2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.16 rows=4 width=28) (actual time=1.369..1.369 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=2 width=28) (actual time=0.977..0.978 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:2  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.325..0.325 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.045..0.046 rows=0 loops=1)
 Planning Time: 0.231 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 2 workers, 4157K bytes max.  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.264 ms
(19 rows)

:explain select * from t2 a left join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.203..1.203 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.08 rows=2 width=24) (actual time=0.537..0.538 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.325 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.652 ms
(16 rows)

:explain select * from t2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=0.750..0.750 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.501..0.502 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.248 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.156 ms
(19 rows)

:explain select * from t2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.841..0.841 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.409..0.410 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
 Planning Time: 0.262 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.199 ms
(16 rows)

:explain select * from t2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.16 rows=4 width=28) (actual time=2.266..2.266 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=28) (actual time=0.633..0.634 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:2  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
 Planning Time: 0.361 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 2 workers, 4157K bytes max.  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 2 workers, 51K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 64.899 ms
(19 rows)

:explain select * from t2 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.476..1.476 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.721..0.722 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.739 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.247 ms
(16 rows)

:explain select * from d2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.824..1.825 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.368..1.369 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.479..0.479 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.210..0.211 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.209..0.209 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.044..0.044 rows=0 loops=1)
 Planning Time: 0.369 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.480 ms
(19 rows)

:explain select * from d2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.501..1.502 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.074..1.075 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.388..0.388 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.025..0.026 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
 Planning Time: 0.407 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.068 ms
(16 rows)

:explain select * from d2 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.588..0.589 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.015 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.282 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.091 ms
(12 rows)

:explain select * from d2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.341..0.341 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.348 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.834 ms
(12 rows)

:explain select * from d2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.545..1.545 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.186..1.187 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.489..0.489 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.090..0.090 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.089..0.089 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.355 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.118 ms
(19 rows)

:explain select * from d2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.689..1.689 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.338..1.338 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.822..0.823 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.821..0.822 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.427 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.258 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.681..1.681 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.322..1.323 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.849..0.849 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.848..0.848 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
 Planning Time: 0.303 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.251 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.644..1.644 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.259..1.260 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.794..0.794 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
 Planning Time: 0.413 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.221 ms
(16 rows)

:explain select * from r2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.981..1.982 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.608..1.608 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.174..1.174 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.173..1.173 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.036..0.036 rows=0 loops=1)
 Planning Time: 0.275 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.572 ms
(19 rows)

:explain select * from r2 a left join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.812..1.812 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.435..1.435 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.001..1.002 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.000..1.001 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.342 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.386 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.704..1.704 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.300..1.300 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.866..0.866 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.865..0.865 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
 Planning Time: 0.333 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.232 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.749..1.749 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.200..1.200 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.759..0.760 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.759..0.759 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.422 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.283 ms
(19 rows)

-- x2 left join y2
:explain select * from t2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=5.836..5.836 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.08 rows=1 width=28) (actual time=4.143..4.148 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 4:4  (slice3; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
 Planning Time: 0.524 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 4 workers, 4157K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 68.790 ms
(19 rows)

:explain select * from t2 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.02..2.10 rows=3 width=24) (actual time=1.973..1.973 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.05 rows=1 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.710 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 4 workers, 64K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 53.149 ms
(12 rows)

:explain select * from t2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=1.656..1.656 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.730..0.730 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.297 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes avg x 2 workers, 4114K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.076 ms
(13 rows)

:explain select * from t2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=1.125..1.125 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.684..0.684 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.297 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.531 ms
(13 rows)

:explain select * from t2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=5.553..5.553 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=1 width=28) (actual time=4.590..4.595 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.014..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.258 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 4 workers, 4157K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 56.690 ms
(19 rows)

:explain select * from t2 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.779..1.779 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.800..0.801 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.026..0.027 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.349 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.046 ms
(16 rows)

:explain select * from d2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.958..1.958 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.462..1.462 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.044..0.044 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.036 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.613..0.613 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.612..0.612 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.043..0.043 rows=0 loops=1)
 Planning Time: 0.362 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.566 ms
(19 rows)

:explain select * from d2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.529..1.529 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.963..0.964 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.287..0.287 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.342 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.985 ms
(16 rows)

:explain select * from d2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.372..0.372 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.242 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.824 ms
(12 rows)

:explain select * from d2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.365..0.365 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.305 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.809 ms
(12 rows)

:explain select * from d2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.613..1.614 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.274..1.274 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.641..0.641 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.640..0.640 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.277 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.235 ms
(19 rows)

:explain select * from d2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=1.674..1.674 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.317..1.317 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.739..0.740 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.739..0.739 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.349 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.274 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.682..1.682 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.302..1.302 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.744..0.745 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.744..0.744 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.344 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.294 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.728..1.728 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.358..1.358 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.812..0.813 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.355 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.218 ms
(16 rows)

:explain select * from r2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.320..0.320 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.007..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.742 ms
(12 rows)

:explain select * from r2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.342..0.342 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.229 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.710 ms
(12 rows)

:explain select * from r2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.748..1.749 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.247..1.248 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.653..0.654 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.652..0.652 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.221 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4117K bytes max (seg1).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.242 ms
(19 rows)

:explain select * from r2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=1.698..1.699 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.323..1.323 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.111..0.111 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.645..0.646 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.644..0.644 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
 Planning Time: 0.189 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.093 ms
(19 rows)

--
-- insert
--
insert into t1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

begin;
insert into t1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into t2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

rollback;
begin;
insert into t1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into t2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
 10 |   
 11 |   
 12 |   
 14 |   
 15 |   
 16 |   
 18 |   
 19 |   
 20 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 13 |   
 17 |   
(20 rows)

insert into d2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  5 |   
  8 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 19 |   
  2 |   
  3 |   
  4 |   
  6 |   
  7 |   
  9 |   
 10 |   
 11 |   
 18 |   
 20 |   
(20 rows)

rollback;
begin;
insert into t1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(12 rows)

insert into t1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into t2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  5
    |  2
    |  3
    |  4
    |  6
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(30 rows)

insert into d1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(24 rows)

insert into d2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
(6 rows)

rollback;
begin;
insert into r1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(42 rows)

insert into r1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  5 |   
  1 |   
  2 |   
  4 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  3
    |  4
    |  2
    |  5
    |  6
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  4 |   
  5 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  5 |   
    |  1
    |  3
    |  4
  1 |   
  2 |   
  4 |   
  5 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  4 |   
  6 |   
    |  2
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  3 |   
  6 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(36 rows)

rollback;
--
-- pg_relation_size() dispatches an internal query, to fetch the relation's
-- size on each segment. The internal query doesn't need to be part of the
-- distributed transactin. Test that we correctly issue two-phase commit in
-- those segments that are affected by the INSERT, and that we don't try
-- to perform distributed commit on the other segments.
--
insert into r1 (c4) values (pg_relation_size('r2'));
--
-- copy to a partial replicated table from file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_from (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

copy partial_rpt_from (c1, c2) from stdin with delimiter ',';
select * from gp_dist_random('partial_rpt_from');
 c1 | c2 
----+----
  1 |  2
  1 |  2
(2 rows)

--
-- copy from a partial replicated table to file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_to (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into partial_rpt_to values (1,1);
copy partial_rpt_to to stdout;
1	1
-- change a replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- change to another replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- start_ignore
-- We need to do a cluster expansion which will check if there are partial
-- tables, we need to drop the partial tables to keep the cluster expansion
-- run correctly.
reset search_path;
drop schema test_partial_table cascade;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table test_partial_table.t1
drop cascades to table test_partial_table.d1
drop cascades to table test_partial_table.r1
drop cascades to table test_partial_table.t2
drop cascades to table test_partial_table.d2
drop cascades to table test_partial_table.r2
drop cascades to table test_partial_table.size_sanity_check
drop cascades to table test_partial_table.partial_rpt_from
drop cascades to table test_partial_table.partial_rpt_to
-- end_ignore
