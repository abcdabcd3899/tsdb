-- TODO: inherit tables
-- TODO: partition tables
-- TODO: ao tables
-- TODO: tables and temp tables
\set explain 'explain analyze'
create extension if not exists gp_debug_numsegments;
NOTICE:  extension "gp_debug_numsegments" already exists, skipping
drop schema if exists test_partial_table;
NOTICE:  schema "test_partial_table" does not exist, skipping
create schema test_partial_table;
set search_path=test_partial_table,public;
set allow_system_table_mods=true;
--
-- prepare kinds of tables
--
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t1 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d1 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r1 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t2 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d2 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r2 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in (
		't1'::regclass, 'd1'::regclass, 'r1'::regclass,
		't2'::regclass, 'd2'::regclass, 'r2'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t1       | 1 2     | p          |           1
 d1       |         | r          |           1
 r1       |         | p          |           1
 t2       | 1 2     | p          |           2
 d2       |         | r          |           2
 r2       |         | p          |           2
(6 rows)

analyze t1;
analyze d1;
analyze r1;
analyze t2;
analyze d2;
analyze r2;
--
-- regression tests
--
-- Test numsegments properity cannot be larger than the size of cluster
create table size_sanity_check(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
update gp_distribution_policy set numsegments = 10 where localoid = 'size_sanity_check'::regclass;
select * from size_sanity_check;
ERROR:  cannot access table "size_sanity_check" in current transaction
LINE 1: select * from size_sanity_check;
                      ^
DETAIL:  New segments are concurrently added to the cluster during the execution of current transaction, the table has data on some of the new segments, but these new segments are invisible and inaccessible to current transaction.
HINT:  Re-run the query in a new transaction.
update gp_distribution_policy set numsegments = 3 where localoid = 'size_sanity_check'::regclass;
-- a temp table is created during reorganization, its numsegments should be
-- the same with original table, otherwise some data will be lost after the
-- reorganization.
--
-- in most cases the temp table is created with CTAS.
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

abort;
-- but there are also cases the temp table is created with CREATE + INSERT.
-- case 1: with dropped columns
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	alter table t1 drop column c4;
	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 
---------------+----+----+----
             0 |  1 |  1 |   
             0 |  2 |  2 |   
             0 |  3 |  3 |   
             0 |  4 |  4 |   
             0 |  5 |  5 |   
             0 |  6 |  6 |   
             0 |  7 |  7 |   
             0 |  8 |  8 |   
             0 |  9 |  9 |   
             0 | 10 | 10 |   
(10 rows)

abort;
-- case 2: AOCO
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=column)
	  distributed by (c1, c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- case 3: AO + index
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=row)
	  distributed by (c1, c2);
	create index ti on t (c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- restore the analyze information
analyze t1;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- append SingleQE of different sizes
select max(c1) as v, 1 as r from t2 union all select 1 as v, 2 as r;
 v | r 
---+---
   | 1
 1 | 2
(2 rows)

-- append node should use the max numsegments of all the subpaths
begin;
	-- insert enough data to ensure executors got reached on segments
	insert into t1 select i from generate_series(1,100) i;
	insert into t2 select i from generate_series(1,100) i;
	:explain  select * from t2 a join t2 b using(c2)
	union all select * from t1 c join t1 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..4.39 rows=10 width=28) (actual time=14.319..14.319 rows=0 loops=1)
   ->  Append  (cost=1.04..4.24 rows=5 width=28) (actual time=10.299..10.299 rows=0 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=7.254..7.255 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: a.c2
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.049..0.069 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=4.899..4.899 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.019..4.869 rows=100 loops=1)
                           Hash Key: b.c2
                           ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.053..0.073 rows=52 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=3.039..3.040 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Seq Scan on t1 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.538..0.538 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.522 rows=100 loops=1)
 Planning Time: 0.671 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2088K bytes avg x 2 workers, 2093K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 40K bytes max (seg0).
   (slice3)    Executor memory: 40K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 37.102 ms
(26 rows)

	:explain  select * from t1 a join t1 b using(c2)
	union all select * from t2 c join t2 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..4.39 rows=10 width=28) (actual time=4.512..4.512 rows=0 loops=1)
   ->  Append  (cost=1.02..4.24 rows=5 width=28) (actual time=2.738..2.738 rows=0 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=2.280..2.281 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.063..0.064 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.049 rows=100 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=0.455..0.455 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: c.c2
                     ->  Seq Scan on t2 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.053 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.069..0.069 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.016..0.047 rows=100 loops=1)
                           Hash Key: d.c2
                           ->  Seq Scan on t2 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.056 rows=52 loops=1)
 Planning Time: 0.510 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2091K bytes avg x 2 workers, 2094K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 6.486 ms
(26 rows)

abort;
-- partitioned table should have the same numsegments for parent and children
-- even in RANDOM mode.
select gp_debug_set_create_table_default_numsegments('random');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 RANDOM
(1 row)

begin;
	create table t (c1 int, c2 int) distributed by (c1)
	partition by range(c2) (start(0) end(20) every(1));
	-- verify that parent and children have the same numsegments
	select count(a.localoid)
	  from gp_distribution_policy a
	  join pg_class c
	    on a.localoid = c.oid
	   and c.relname like 't_1_prt_%'
	  join gp_distribution_policy b
	    on a.numsegments = b.numsegments
	   and b.localoid = 't'::regclass
	;
 count 
-------
    20
(1 row)

abort;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- verify numsegments in subplans
:explain select * from t1, t2
   where t1.c1 > any (select max(t2.c1) from t2 where t2.c2 = t1.c2)
     and t2.c1 > any (select max(t1.c1) from t1 where t1.c2 = t2.c2);
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000002.12 rows=3 width=32) (actual time=0.918..0.918 rows=0 loops=1)
   ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=32) (actual time=0.036..0.036 rows=0 loops=1)
         ->  Seq Scan on t1  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                       ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                             Filter: (t2_1.c2 = t1.c2)
                             ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                   ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                         ->  Seq Scan on t2 t2_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.108..0.108 rows=0 loops=1)
         ->  Materialize  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     ->  Seq Scan on t2  (cost=0.00..1.01 rows=1 width=16) (actual time=0.046..0.046 rows=0 loops=1)
                           Filter: (SubPlan 2)
                           SubPlan 2
                             ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                                   ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                                         Filter: (t1_1.c2 = t2.c2)
                                         ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                               ->  Broadcast Motion 1:2  (slice4; segments: 1)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                                     ->  Seq Scan on t1 t1_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.048..0.048 rows=0 loops=1)
 Planning Time: 0.246 ms
   (slice0)    Executor memory: 83K bytes.
   (slice1)    Executor memory: 50K bytes (seg0).
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 40K bytes max (seg0).
   (slice3)    Executor memory: 52K bytes avg x 2 workers, 52K bytes max (seg0).
   (slice4)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 24.908 ms
(31 rows)

--
-- It is used to test this case:
--   A: replicated table, distributed on 2 segments
--   B: replicated table, distributed on 1 segments
--   UPDATE A SET XXX FROM B WHERE XXX;
-- We have to add a broadcast motion on B so that A can update/delete correctly.
--
begin;
    insert into d1 select i,i,i,i from generate_series(1,2) i;
    insert into d2 select i,i,i,i from generate_series(1,3) i;
    explain update d2 a set c3=b.c3 from d1 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice1; segments: 2)  (cost=10000000002.06..10000000002.06 rows=3 width=44)
   ->  Update on d2 a  (cost=10000000000.00..10000000002.06 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=44)
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Materialize  (cost=0.00..1.03 rows=1 width=22)
                     ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=22)
                           ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(8 rows)

    update d2 a set c3=b.c3 from d1 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
  3 |  3 |  1 |  3 |  1 |  1 |  1 |  1
(3 rows)

    explain update d1 a set c3=b.c3 from d2 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000002.03..10000000002.03 rows=3 width=44)
   ->  Update on d1 a  (cost=10000000000.00..10000000002.03 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.03 rows=3 width=44)
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(6 rows)

    update d1 a set c3=b.c3 from d2 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
(2 rows)

abort;
-- restore the analyze information
analyze d1;
analyze d2;
--
-- create table: LIKE, INHERITS and DISTRIBUTED BY
--
-- tables are always created with DEFAULT as numsegments,
-- no matter there is LIKE, INHERITS or DISTRIBUTED BY.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

-- none of the clauses
create table t ();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY only
create table t () distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS only
create table t () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- LIKE only
create table t (like d1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS
create table t () inherits (t2) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + LIKE
create table t (like d1) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS + LIKE
create table t (like d1) inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS + LIKE
create table t (like d1) inherits (t2) distributed randomly;
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS from multiple parents
create table t () inherits (r1, t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS from multiple parents
create table t () inherits (r1, t2) distributed by (c1);
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1       | p          |           2
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- CTAS set numsegments with DEFAULT,
-- let it be a fixed value to get stable output
select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

create table t as table t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           3
(1 row)

drop table t;
select * into table t from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

--
-- alter table
--
-- numsegments should not be changed
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t (like t1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t set distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           1
(1 row)

alter table t set distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           1
(1 row)

alter table t set distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t add column c10 int;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t alter column c10 type text;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- below join cases cover all the combinations of
--
--     select * from {t,d,r}{1,2} a
--      {left,} join {t,d,r}{1,2} b
--      using (c1{',c2',});
--
-- there might be some duplicated ones, like 't1 join d1' and 'd1 join t1',
-- or 'd1 join r1 using (c1)' and 'd1 join r1 using (c1, c2)', this is because
-- we generate them via scripts and do not clean them up manually.
--
-- please do not remove the duplicated ones as we care about the motion
-- direction of different join orders, e.g. 't2 join t1' and 't1 join t2'
-- should both distribute t2 to t1.
--
-- JOIN
--
-- x1 join y1
:explain select * from t1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.095..0.095 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.150 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.562 ms
(12 rows)

:explain select * from t1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.212..0.212 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.161 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.533 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.261..0.261 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.012..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.149 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.530 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.312..0.312 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.579 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.323..0.323 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.231 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.550 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.202..0.203 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.206 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.516 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.274..0.275 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.124 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.535 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.239..0.239 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.151 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.532 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.307..0.308 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.132 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.546 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.328..0.329 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.155 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.567 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.259..0.260 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.176 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.555 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.243..0.243 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.190 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.555 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.245..0.245 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.014 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.160 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 22K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.561 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.280..0.281 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.219 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 26K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.552 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.297..0.298 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.182 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 22K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.554 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.349..0.349 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.203 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 26K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.585 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.318..0.318 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.040..0.040 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.039..0.039 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.228 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.725 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.841..0.841 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.233 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.189 ms
(12 rows)

-- x1 join y2
:explain select * from t1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=3.448..3.448 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=2.978..2.979 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.048..0.048 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.251 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 12.430 ms
(15 rows)

:explain select * from t1 a join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=3.092..3.092 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=2.425..2.426 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.046..0.046 rows=0 loops=1)
 Planning Time: 0.288 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.648 ms
(16 rows)

:explain select * from t1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.516..0.516 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.137 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.781 ms
(12 rows)

:explain select * from t1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.313..0.313 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.167 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.658 ms
(12 rows)

:explain select * from t1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=4.540..4.540 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=3.328..3.329 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
 Planning Time: 0.220 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 8.204 ms
(15 rows)

:explain select * from t1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=3.087..3.087 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=2.835..2.836 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.210 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 27K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.740 ms
(16 rows)

:explain select * from d1 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=2.555..2.556 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.855..1.855 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.040..0.040 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.169..1.169 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.168..1.168 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.073..0.073 rows=0 loops=1)
 Planning Time: 0.234 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 27K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 9.234 ms
(19 rows)

:explain select * from d1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=4.565..4.565 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.816..0.817 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.043..0.043 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.042..0.042 rows=0 loops=1)
 Planning Time: 0.251 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4123K bytes avg x 2 workers, 4123K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.906 ms
(16 rows)

:explain select * from d1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.280..0.281 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.149 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.538 ms
(12 rows)

:explain select * from d1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.295..0.295 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.148 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.552 ms
(12 rows)

:explain select * from d1 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.678..2.678 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=2.232..2.233 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.036..0.036 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.024 rows=0 loops=1)
 Planning Time: 0.130 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.634 ms
(19 rows)

:explain select * from d1 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=2.797..2.797 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=2.447..2.447 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.024 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
 Planning Time: 0.177 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 27K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.141 ms
(19 rows)

:explain select * from r1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=2.486..2.486 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=2.240..2.240 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.069..0.069 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.202 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.913 ms
(15 rows)

:explain select * from r1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.864..0.865 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.645..0.645 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.234 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4123K bytes avg x 2 workers, 4123K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.354 ms
(16 rows)

:explain select * from r1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.275..0.275 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.161 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 22K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.677 ms
(12 rows)

:explain select * from r1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.277..0.277 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.184 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 26K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.462 ms
(12 rows)

:explain select * from r1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=2.573..2.574 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=2.305..2.305 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.146 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.941 ms
(15 rows)

:explain select * from r1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=3.447..3.448 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=2.534..2.534 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.189 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.684 ms
(15 rows)

-- x2 join y1
:explain select * from t2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=2.806..2.806 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=2.380..2.380 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.014..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
 Planning Time: 0.215 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.545 ms
(15 rows)

:explain select * from t2 a join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=5.351..5.352 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=0.955..0.956 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.107..0.107 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.106..0.106 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
 Planning Time: 0.206 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 5.616 ms
(16 rows)

:explain select * from t2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=2.407..2.408 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=2.037..2.037 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.037 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.211..1.211 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.210..1.210 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
 Planning Time: 0.232 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.118 ms
(19 rows)

:explain select * from t2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.783..2.783 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=2.443..2.443 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.255 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.403 ms
(16 rows)

:explain select * from t2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.687..0.687 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.361..0.361 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.065..0.065 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.242 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.034 ms
(15 rows)

:explain select * from t2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.206..1.206 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.882..0.883 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.286 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.946 ms
(16 rows)

:explain select * from d2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.132..0.132 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.167 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.544 ms
(12 rows)

:explain select * from d2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.523..0.523 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.162 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.768 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.161..0.162 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.279 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.750 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.339..0.339 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.167 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.826 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.225..0.225 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.527 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.227..0.227 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.192 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.510 ms
(12 rows)

:explain select * from r2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.080..1.080 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.817..0.817 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.148 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.789 ms
(15 rows)

:explain select * from r2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.995..0.995 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.690..0.690 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.145 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4123K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.681 ms
(16 rows)

:explain select * from r2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.960..0.960 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.717..0.717 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
 Planning Time: 0.181 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.002 ms
(19 rows)

:explain select * from r2 a join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=2.430..2.430 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=2.143..2.144 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.382..1.382 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.381..1.381 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.051..0.051 rows=0 loops=1)
 Planning Time: 0.189 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.921 ms
(19 rows)

:explain select * from r2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=1.449..1.449 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.963..0.963 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.198 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.828 ms
(15 rows)

:explain select * from r2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.995..0.996 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.818..0.819 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.235 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4123K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.885 ms
(15 rows)

-- x2 join y2
:explain select * from t2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.326..2.326 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.900..1.900 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.164..1.165 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.163..1.163 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.321 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 40K bytes max (seg1).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 40K bytes max (seg1).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 15.349 ms
(19 rows)

:explain select * from t2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.357..0.358 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.011..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.268 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.686 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.424..0.424 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.016..0.016 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.186 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 22K bytes avg x 2 workers, 22K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.767 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.322..0.323 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.227 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 26K bytes avg x 2 workers, 26K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.647 ms
(12 rows)

:explain select * from t2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.049..2.049 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.707..1.707 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.959..0.959 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.958..0.958 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
 Planning Time: 0.229 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.845 ms
(19 rows)

:explain select * from t2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.202..1.202 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.850..0.850 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.254 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.093 ms
(16 rows)

:explain select * from d2 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.277..0.277 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.220 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.594 ms
(12 rows)

:explain select * from d2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.886..0.886 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.281 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.313 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.298..0.298 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.173 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.629 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.278..0.278 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.147 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.616 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.301..0.302 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.099 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 32K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.575 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.693..0.693 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.160 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.230 ms
(12 rows)

:explain select * from r2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=6.545..6.545 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=4.674..4.681 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.032..0.032 rows=0 loops=1)
 Planning Time: 0.233 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 7.084 ms
(19 rows)

:explain select * from r2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.034..2.034 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.080..1.080 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.040..0.040 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.242 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4123K bytes avg x 2 workers, 4123K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.691 ms
(16 rows)

:explain select * from r2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.326..0.326 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.034..0.034 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.130 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.639 ms
(12 rows)

:explain select * from r2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.236..0.236 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.164 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.536 ms
(12 rows)

:explain select * from r2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.410..2.410 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=2.071..2.071 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.291..1.291 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.290..1.290 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.024 rows=0 loops=1)
 Planning Time: 0.151 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.106 ms
(19 rows)

:explain select * from r2 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=2.147..2.147 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.838..1.838 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.959..0.959 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.958..0.958 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.807 ms
(19 rows)

-- x1 left join y1
:explain select * from t1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.296..0.296 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.161 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.573 ms
(12 rows)

:explain select * from t1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.239..0.239 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.172 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.465 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.391..0.391 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.147 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.678 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.243..0.243 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.126 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.467 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.244..0.244 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.179 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.548 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.410..0.410 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.258 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.689 ms
(12 rows)

:explain select * from d1 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.580..2.580 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=2.239..2.240 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.444..1.445 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.443..1.443 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.042..0.043 rows=0 loops=1)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.565 ms
(19 rows)

:explain select * from d1 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=2.219..2.219 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.657..1.658 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.749..0.749 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.039..0.039 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.019 rows=0 loops=1)
 Planning Time: 0.219 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.907 ms
(16 rows)

:explain select * from d1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.412..0.412 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.794 ms
(12 rows)

:explain select * from d1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.331..0.331 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.192 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.593 ms
(12 rows)

:explain select * from d1 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=2.706..2.706 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=2.412..2.412 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
 Planning Time: 0.226 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.164 ms
(19 rows)

:explain select * from d1 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=2.032..2.032 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.739..1.739 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.856..0.856 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.855..0.855 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
 Planning Time: 0.196 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.469 ms
(19 rows)

:explain select * from r1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=1.149..1.149 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.705..0.705 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.207 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.331 ms
(13 rows)

:explain select * from r1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=1.044..1.045 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.805..0.806 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.210 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.488 ms
(13 rows)

:explain select * from r1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.950..0.950 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.189..0.190 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.243 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.274 ms
(13 rows)

:explain select * from r1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.939..0.940 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.752..0.753 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
 Planning Time: 0.174 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.198 ms
(13 rows)

:explain select * from r1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.232..0.232 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.273 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.536 ms
(12 rows)

:explain select * from r1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.253..0.254 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.175 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.491 ms
(12 rows)

-- x1 left join y2
:explain select * from t1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.344..1.344 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.732..0.733 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.037 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.203 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.889 ms
(15 rows)

:explain select * from t1 a left join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=2.802..2.802 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.08 rows=2 width=24) (actual time=0.650..0.651 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
 Planning Time: 0.270 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.284 ms
(16 rows)

:explain select * from t1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.385..0.385 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.170 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.601 ms
(12 rows)

:explain select * from t1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.257..0.258 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.029..0.029 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.204 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.559 ms
(12 rows)

:explain select * from t1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.029..1.029 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.776..0.776 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.147 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.781 ms
(15 rows)

:explain select * from t1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.881..0.881 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.633..0.633 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.144 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 27K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.806 ms
(16 rows)

:explain select * from d1 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.006..1.006 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.957..0.957 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.032..0.032 rows=0 loops=1)
 Planning Time: 0.241 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.751 ms
(19 rows)

:explain select * from d1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.950..2.950 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.795..0.796 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.240 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes avg x 2 workers, 4124K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.793 ms
(16 rows)

:explain select * from d1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.336..0.336 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.171 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.574 ms
(12 rows)

:explain select * from d1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.299..0.300 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.168 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.555 ms
(12 rows)

:explain select * from d1 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.187..2.187 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.829..1.830 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.069..1.070 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.068..1.068 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.051..0.051 rows=0 loops=1)
 Planning Time: 0.170 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.869 ms
(19 rows)

:explain select * from d1 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.943..1.943 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.624..1.624 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.076..0.076 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.784..0.784 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.783..0.783 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
 Planning Time: 0.199 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 27K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.610 ms
(19 rows)

:explain select * from r1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.069..1.069 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.777..0.777 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.243 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.852 ms
(15 rows)

:explain select * from r1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.768..2.768 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.339..0.340 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.281 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes avg x 2 workers, 4124K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.263 ms
(16 rows)

:explain select * from r1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=1.109..1.109 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.817..0.818 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.445 ms
(13 rows)

:explain select * from r1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=1.142..1.143 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.783..0.784 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
 Planning Time: 0.236 ms
   (slice0)    Executor memory: 34K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.637 ms
(13 rows)

:explain select * from r1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.547..0.547 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.223..0.224 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.193 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.967 ms
(15 rows)

:explain select * from r1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.178..1.178 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.797..0.798 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.218 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 25K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.985 ms
(15 rows)

-- x2 left join y1
:explain select * from t2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=2.079..2.079 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.882..1.883 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.036 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.078..1.078 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.076..1.076 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
 Planning Time: 0.259 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.708 ms
(19 rows)

:explain select * from t2 a left join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.501..1.501 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.08 rows=2 width=24) (actual time=1.196..1.197 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.036..0.036 rows=0 loops=1)
 Planning Time: 0.263 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.185 ms
(16 rows)

:explain select * from t2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=2.117..2.117 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.772..1.773 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.940..0.940 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.939..0.939 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.252 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.551 ms
(19 rows)

:explain select * from t2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.125..2.125 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.783..1.784 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.247 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.638 ms
(16 rows)

:explain select * from t2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.887..1.888 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.618..1.618 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.058..0.058 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.872..0.872 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.871..0.871 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
 Planning Time: 0.323 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.291 ms
(19 rows)

:explain select * from t2 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.987..0.987 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.827..0.828 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.283 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.963 ms
(16 rows)

:explain select * from d2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.220..2.220 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.927..1.928 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.257..0.257 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.048..0.048 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.890..0.890 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.888..0.888 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
 Planning Time: 0.189 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.715 ms
(19 rows)

:explain select * from d2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.992..1.992 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.801..1.801 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.715..0.715 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.018..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
 Planning Time: 0.190 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.776 ms
(16 rows)

:explain select * from d2 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.394..0.395 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.011..0.012 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.165 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.685 ms
(12 rows)

:explain select * from d2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.702..0.702 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.011..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.167 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.039 ms
(12 rows)

:explain select * from d2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=3.450..3.450 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.650..1.650 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.771..0.771 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.770..0.770 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
 Planning Time: 0.223 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.142 ms
(19 rows)

:explain select * from d2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.892..1.892 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.623..1.623 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.056..0.057 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.914..0.914 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.913..0.914 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
 Planning Time: 0.257 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.338 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.614..1.614 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.483..1.483 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.818..0.818 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.037 rows=0 loops=1)
 Planning Time: 0.125 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.036 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=3.050..3.050 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=2.795..2.796 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.965..1.966 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.210 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.618 ms
(16 rows)

:explain select * from r2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.147..2.147 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.782..1.782 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.044..1.044 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.043..1.043 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
 Planning Time: 0.187 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.551 ms
(19 rows)

:explain select * from r2 a left join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=2.020..2.020 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.787..1.788 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.969..0.970 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.968..0.968 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.178 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.525 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.915..1.916 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.539..1.540 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.027..0.027 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.756..0.757 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.755..0.756 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.205 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.541 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=2.333..2.333 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.821..1.822 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.031 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.029..1.029 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.028..1.028 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.281 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 26K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.671 ms
(19 rows)

-- x2 left join y2
:explain select * from t2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=3.520..3.520 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.787..1.788 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.039..0.039 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.846..0.846 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.831..0.831 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.194 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.100 ms
(19 rows)

:explain select * from t2 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.262..0.262 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.258 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.580 ms
(12 rows)

:explain select * from t2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=3.053..3.053 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.739..0.739 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.186 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.919 ms
(13 rows)

:explain select * from t2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=1.318..1.318 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.756..0.757 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.249 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.974 ms
(13 rows)

:explain select * from t2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.328..2.328 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.09 rows=2 width=28) (actual time=2.046..2.046 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.287..1.287 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.286..1.286 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
 Planning Time: 0.237 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.005 ms
(19 rows)

:explain select * from t2 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=5.480..5.481 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.813..1.813 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.255 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 5.860 ms
(16 rows)

:explain select * from d2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.088..2.088 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.789..1.789 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.695..0.695 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.694..0.694 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
 Planning Time: 0.263 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.698 ms
(19 rows)

:explain select * from d2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.959..1.960 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.664..1.665 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.927..0.927 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.228 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes avg x 2 workers, 4124K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.374 ms
(16 rows)

:explain select * from d2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.265..0.265 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.153 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.608 ms
(12 rows)

:explain select * from d2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.049..0.049 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.157 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.517 ms
(12 rows)

:explain select * from d2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.720..2.720 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.324..1.324 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.063..0.063 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.078..1.078 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.077..1.077 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.148 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.302 ms
(19 rows)

:explain select * from d2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=2.062..2.063 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.792..1.793 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.029..0.030 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.027..1.027 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.025..1.025 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.028..0.028 rows=0 loops=1)
 Planning Time: 0.187 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.705 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.919..1.919 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.739..1.739 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.136..0.136 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.022 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.849..0.849 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.847..0.847 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.230 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.552 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.932..1.932 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.691..1.691 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.922..0.922 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.249 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4124K bytes avg x 2 workers, 4124K bytes max (seg1).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 38K bytes avg x 2 workers, 38K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.505 ms
(16 rows)

:explain select * from r2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.179..0.179 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.216 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.567 ms
(12 rows)

:explain select * from r2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.262..0.262 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.005..0.005 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.182 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 27K bytes avg x 2 workers, 27K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.674 ms
(12 rows)

:explain select * from r2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.111..2.111 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.821..1.822 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.032..0.032 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.961..0.961 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.959..0.959 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.155 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.775 ms
(19 rows)

:explain select * from r2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=2.103..2.103 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.942..1.942 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.050..0.051 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.050..0.050 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.064..1.065 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.063..1.063 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.025..0.025 rows=0 loops=1)
 Planning Time: 0.207 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
   (slice3)    Executor memory: 39K bytes avg x 2 workers, 39K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.837 ms
(19 rows)

--
-- insert
--
insert into t1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

begin;
insert into t1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into t2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

rollback;
begin;
insert into t1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into t2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 13 |   
 17 |   
 10 |   
 11 |   
 12 |   
 14 |   
 15 |   
 16 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  5 |   
  8 |   
 11 |   
 15 |   
 19 |   
  1 |   
  2 |   
  6 |   
  7 |   
  9 |   
 10 |   
 12 |   
 13 |   
 14 |   
 16 |   
 17 |   
 18 |   
 20 |   
(20 rows)

rollback;
begin;
insert into t1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(12 rows)

insert into t1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into t2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  2
    |  3
    |  4
    |  6
    |  1
    |  5
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(30 rows)

insert into d1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(24 rows)

insert into d2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
(6 rows)

rollback;
begin;
insert into r1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(42 rows)

insert into r1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  3 |   
  5 |   
  2 |   
  4 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  2
    |  3
    |  4
    |  5
    |  1
    |  6
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  6 |   
  1 |   
  3 |   
  4 |   
  5 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  6 |   
  5 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  4 |   
  5 |   
  6 |   
  1 |   
  3 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  2 |   
  4 |   
  6 |   
    |  1
    |  6
  1 |   
  3 |   
  4 |   
  5 |   
  5 |   
  1 |   
  3 |   
  6 |   
  1 |   
  3 |   
  5 |   
    |  2
    |  3
    |  4
    |  5
  2 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  6 |   
  2 |   
  4 |   
  5 |   
  6 |   
(36 rows)

rollback;
--
-- pg_relation_size() dispatches an internal query, to fetch the relation's
-- size on each segment. The internal query doesn't need to be part of the
-- distributed transactin. Test that we correctly issue two-phase commit in
-- those segments that are affected by the INSERT, and that we don't try
-- to perform distributed commit on the other segments.
--
insert into r1 (c4) values (pg_relation_size('r2'));
--
-- copy to a partial replicated table from file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_from (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

copy partial_rpt_from (c1, c2) from stdin with delimiter ',';
select * from gp_dist_random('partial_rpt_from');
 c1 | c2 
----+----
  1 |  2
  1 |  2
(2 rows)

--
-- copy from a partial replicated table to file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_to (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into partial_rpt_to values (1,1);
copy partial_rpt_to to stdout;
1	1
-- change a replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- change to another replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- start_ignore
-- We need to do a cluster expansion which will check if there are partial
-- tables, we need to drop the partial tables to keep the cluster expansion
-- run correctly.
reset search_path;
drop schema test_partial_table cascade;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table test_partial_table.t1
drop cascades to table test_partial_table.d1
drop cascades to table test_partial_table.r1
drop cascades to table test_partial_table.t2
drop cascades to table test_partial_table.d2
drop cascades to table test_partial_table.r2
drop cascades to table test_partial_table.size_sanity_check
drop cascades to table test_partial_table.partial_rpt_from
drop cascades to table test_partial_table.partial_rpt_to
-- end_ignore
