-- TODO: inherit tables
-- TODO: partition tables
-- TODO: ao tables
-- TODO: tables and temp tables
\set explain 'explain analyze'
create extension if not exists gp_debug_numsegments;
NOTICE:  extension "gp_debug_numsegments" already exists, skipping
drop schema if exists test_partial_table;
NOTICE:  schema "test_partial_table" does not exist, skipping
create schema test_partial_table;
set search_path=test_partial_table,public;
set allow_system_table_mods=true;
--
-- prepare kinds of tables
--
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t1 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d1 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r1 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t2 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d2 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r2 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in (
		't1'::regclass, 'd1'::regclass, 'r1'::regclass,
		't2'::regclass, 'd2'::regclass, 'r2'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t1       | 1 2     | p          |           1
 d1       |         | r          |           1
 r1       |         | p          |           1
 t2       | 1 2     | p          |           2
 d2       |         | r          |           2
 r2       |         | p          |           2
(6 rows)

analyze t1;
analyze d1;
analyze r1;
analyze t2;
analyze d2;
analyze r2;
--
-- regression tests
--
-- Test numsegments properity cannot be larger than the size of cluster
create table size_sanity_check(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
update gp_distribution_policy set numsegments = 10 where localoid = 'size_sanity_check'::regclass;
select * from size_sanity_check;
ERROR:  cannot access table "size_sanity_check" in current transaction
LINE 1: select * from size_sanity_check;
                      ^
DETAIL:  New segments are concurrently added to the cluster during the execution of current transaction, the table has data on some of the new segments, but these new segments are invisible and inaccessible to current transaction.
HINT:  Re-run the query in a new transaction.
update gp_distribution_policy set numsegments = 3 where localoid = 'size_sanity_check'::regclass;
-- a temp table is created during reorganization, its numsegments should be
-- the same with original table, otherwise some data will be lost after the
-- reorganization.
--
-- in most cases the temp table is created with CTAS.
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

abort;
-- but there are also cases the temp table is created with CREATE + INSERT.
-- case 1: with dropped columns
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	alter table t1 drop column c4;
	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 
---------------+----+----+----
             0 |  1 |  1 |   
             0 |  2 |  2 |   
             0 |  3 |  3 |   
             0 |  4 |  4 |   
             0 |  5 |  5 |   
             0 |  6 |  6 |   
             0 |  7 |  7 |   
             0 |  8 |  8 |   
             0 |  9 |  9 |   
             0 | 10 | 10 |   
(10 rows)

abort;
-- case 2: AOCO
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=column)
	  distributed by (c1, c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- case 3: AO + index
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=row)
	  distributed by (c1, c2);
	create index ti on t (c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- restore the analyze information
analyze t1;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- append SingleQE of different sizes
select max(c1) as v, 1 as r from t2 union all select 1 as v, 2 as r;
 v | r 
---+---
   | 1
 1 | 2
(2 rows)

-- append node should use the max numsegments of all the subpaths
begin;
	-- insert enough data to ensure executors got reached on segments
	insert into t1 select i from generate_series(1,100) i;
	insert into t2 select i from generate_series(1,100) i;
	:explain  select * from t2 a join t2 b using(c2)
	union all select * from t1 c join t1 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..4.39 rows=10 width=28) (actual time=2.660..2.660 rows=0 loops=1)
   ->  Append  (cost=1.04..4.24 rows=5 width=28) (actual time=2.215..2.215 rows=0 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.343..1.346 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: a.c2
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.036 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.053..0.054 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.016..0.038 rows=100 loops=1)
                           Hash Key: b.c2
                           ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.049 rows=52 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.870..0.871 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Seq Scan on t1 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.038..0.039 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.030 rows=100 loops=1)
 Planning Time: 0.493 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2085K bytes avg x 2 workers, 2087K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 16K bytes avg x 2 workers, 16K bytes max (seg0).
   (slice3)    Executor memory: 16K bytes avg x 2 workers, 16K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 17.443 ms
(26 rows)

	:explain  select * from t1 a join t1 b using(c2)
	union all select * from t2 c join t2 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..4.39 rows=10 width=28) (actual time=1.496..1.497 rows=0 loops=1)
   ->  Append  (cost=1.02..4.24 rows=5 width=28) (actual time=1.208..1.208 rows=0 loops=1)
         ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.304..0.305 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=1 loops=1)
               ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.056..0.056 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.044 rows=100 loops=1)
         ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=0.901..0.901 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     Hash Key: c.c2
                     ->  Seq Scan on t2 c  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.024 rows=52 loops=1)
               ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.723..0.723 rows=0 loops=1)
                     Buckets: 262144  Batches: 1  Memory Usage: 2048kB
                     ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.018..0.704 rows=100 loops=1)
                           Hash Key: d.c2
                           ->  Seq Scan on t2 d  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.025 rows=52 loops=1)
 Planning Time: 0.373 ms
   (slice0)    Executor memory: 69K bytes.
   (slice1)    Executor memory: 2086K bytes avg x 2 workers, 2088K bytes max (seg0).  Work_mem: 2048K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.992 ms
(26 rows)

abort;
-- partitioned table should have the same numsegments for parent and children
-- even in RANDOM mode.
select gp_debug_set_create_table_default_numsegments('random');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 RANDOM
(1 row)

begin;
	create table t (c1 int, c2 int) distributed by (c1)
	partition by range(c2) (start(0) end(20) every(1));
	-- verify that parent and children have the same numsegments
	select count(a.localoid)
	  from gp_distribution_policy a
	  join pg_class c
	    on a.localoid = c.oid
	   and c.relname like 't_1_prt_%'
	  join gp_distribution_policy b
	    on a.numsegments = b.numsegments
	   and b.localoid = 't'::regclass
	;
 count 
-------
    20
(1 row)

abort;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- verify numsegments in subplans
:explain select * from t1, t2
   where t1.c1 > any (select max(t2.c1) from t2 where t2.c2 = t1.c2)
     and t2.c1 > any (select max(t1.c1) from t1 where t1.c2 = t2.c2);
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000002.12 rows=3 width=32) (actual time=1.402..1.402 rows=0 loops=1)
   ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=32) (actual time=0.106..0.106 rows=0 loops=1)
         ->  Seq Scan on t1  (cost=0.00..1.01 rows=1 width=16) (actual time=0.100..0.100 rows=0 loops=1)
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                       ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                             Filter: (t2_1.c2 = t1.c2)
                             ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                   ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                         ->  Seq Scan on t2 t2_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.052..0.052 rows=0 loops=1)
         ->  Materialize  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
                     ->  Seq Scan on t2  (cost=0.00..1.01 rows=1 width=16) (actual time=0.060..0.060 rows=0 loops=1)
                           Filter: (SubPlan 2)
                           SubPlan 2
                             ->  Aggregate  (cost=1.05..1.06 rows=1 width=4) (never executed)
                                   ->  Result  (cost=0.00..1.04 rows=1 width=4) (never executed)
                                         Filter: (t1_1.c2 = t2.c2)
                                         ->  Materialize  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                               ->  Broadcast Motion 1:2  (slice4; segments: 1)  (cost=0.00..1.03 rows=1 width=8) (never executed)
                                                     ->  Seq Scan on t1 t1_1  (cost=0.00..1.01 rows=1 width=8) (actual time=0.028..0.028 rows=0 loops=1)
 Planning Time: 0.289 ms
   (slice0)    Executor memory: 83K bytes.
   (slice1)    Executor memory: 35K bytes (seg0).
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 16K bytes max (seg0).
   (slice3)    Executor memory: 28K bytes avg x 2 workers, 28K bytes max (seg0).
   (slice4)    Executor memory: 16K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 43.050 ms
(31 rows)

--
-- It is used to test this case:
--   A: replicated table, distributed on 2 segments
--   B: replicated table, distributed on 1 segments
--   UPDATE A SET XXX FROM B WHERE XXX;
-- We have to add a broadcast motion on B so that A can update/delete correctly.
--
begin;
    insert into d1 select i,i,i,i from generate_series(1,2) i;
    insert into d2 select i,i,i,i from generate_series(1,3) i;
    explain update d2 a set c3=b.c3 from d1 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice1; segments: 2)  (cost=10000000002.06..10000000002.06 rows=3 width=44)
   ->  Update on d2 a  (cost=10000000000.00..10000000002.06 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.06 rows=3 width=44)
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Materialize  (cost=0.00..1.03 rows=1 width=22)
                     ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=22)
                           ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(8 rows)

    update d2 a set c3=b.c3 from d1 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
  3 |  3 |  1 |  3 |  1 |  1 |  1 |  1
(3 rows)

    explain update d1 a set c3=b.c3 from d2 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000002.03..10000000002.03 rows=3 width=44)
   ->  Update on d1 a  (cost=10000000000.00..10000000002.03 rows=3 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.03 rows=3 width=44)
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=22)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=22)
 Optimizer: Postgres query optimizer
(6 rows)

    update d1 a set c3=b.c3 from d2 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
(2 rows)

abort;
-- restore the analyze information
analyze d1;
analyze d2;
--
-- create table: LIKE, INHERITS and DISTRIBUTED BY
--
-- tables are always created with DEFAULT as numsegments,
-- no matter there is LIKE, INHERITS or DISTRIBUTED BY.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

-- none of the clauses
create table t ();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY only
create table t () distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS only
create table t () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- LIKE only
create table t (like d1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS
create table t () inherits (t2) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + LIKE
create table t (like d1) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS + LIKE
create table t (like d1) inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS + LIKE
create table t (like d1) inherits (t2) distributed randomly;
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS from multiple parents
create table t () inherits (r1, t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS from multiple parents
create table t () inherits (r1, t2) distributed by (c1);
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1       | p          |           2
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- CTAS set numsegments with DEFAULT,
-- let it be a fixed value to get stable output
select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

create table t as table t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           3
(1 row)

drop table t;
select * into table t from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

--
-- alter table
--
-- numsegments should not be changed
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t (like t1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t set distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           1
(1 row)

alter table t set distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           1
(1 row)

alter table t set distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t add column c10 int;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t alter column c10 type text;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- below join cases cover all the combinations of
--
--     select * from {t,d,r}{1,2} a
--      {left,} join {t,d,r}{1,2} b
--      using (c1{',c2',});
--
-- there might be some duplicated ones, like 't1 join d1' and 'd1 join t1',
-- or 'd1 join r1 using (c1)' and 'd1 join r1 using (c1, c2)', this is because
-- we generate them via scripts and do not clean them up manually.
--
-- please do not remove the duplicated ones as we care about the motion
-- direction of different join orders, e.g. 't2 join t1' and 't1 join t2'
-- should both distribute t2 to t1.
--
-- JOIN
--
-- x1 join y1
:explain select * from t1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.360..0.360 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.191 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.693 ms
(12 rows)

:explain select * from t1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.202..0.202 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.191 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.504 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.160..0.160 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.113 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.383 ms
(12 rows)

:explain select * from t1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.165..0.165 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.171 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.441 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.812..0.812 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.283 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 57.727 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.689..1.689 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.003..0.003 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.390 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.473 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.741..0.741 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.015 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.137 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.033 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.340..0.340 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.133 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.605 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.296..0.297 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.103 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.537 ms
(12 rows)

:explain select * from d1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.296..0.297 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.125 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.532 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.301..0.301 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.147 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.542 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.295..0.295 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.536 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.841..0.841 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.144 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.625 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.735..1.735 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.002..0.002 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.339 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.557 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.469..0.469 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.238 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.868 ms
(12 rows)

:explain select * from r1 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.187..0.188 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.233 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.497 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.764..0.764 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=28) (actual time=0.003..0.003 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.324 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 62K bytes avg x 2 workers, 62K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.502 ms
(12 rows)

:explain select * from r1 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=1.490..1.490 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.002..0.002 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.250 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 65K bytes avg x 2 workers, 65K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.176 ms
(12 rows)

-- x1 join y2
:explain select * from t1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=2.591..2.591 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=2.028..2.028 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.533 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.204 ms
(15 rows)

:explain select * from t1 a join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=2.730..2.730 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=1.714..1.714 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
 Planning Time: 0.573 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.309 ms
(16 rows)

:explain select * from t1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.205..0.205 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.128 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.454 ms
(12 rows)

:explain select * from t1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.166..0.166 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.410 ms
(12 rows)

:explain select * from t1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.652..0.652 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.477..0.477 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.010..0.011 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.285 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.824 ms
(15 rows)

:explain select * from t1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.928..0.928 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.558..0.558 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.515 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.152 ms
(16 rows)

:explain select * from d1 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.979..1.979 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.605..1.606 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.126..1.127 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.126..1.126 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.031..0.031 rows=0 loops=1)
 Planning Time: 0.290 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 16K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 12.226 ms
(19 rows)

:explain select * from d1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.208..1.208 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.503..0.503 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.021 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.549 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.812 ms
(16 rows)

:explain select * from d1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.197..0.197 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.292 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.651 ms
(12 rows)

:explain select * from d1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.148..0.148 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.005..0.005 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.345 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.575 ms
(12 rows)

:explain select * from d1 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.530..1.530 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.337..1.338 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.896..0.896 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.895..0.895 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.322 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.088 ms
(19 rows)

:explain select * from d1 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.502..1.502 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.277..1.277 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.847..0.847 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.847..0.847 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.284 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 14K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.917 ms
(19 rows)

:explain select * from r1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.899..0.899 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.498..0.499 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
 Planning Time: 0.415 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.732 ms
(15 rows)

:explain select * from r1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.716..0.716 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.467..0.467 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
 Planning Time: 0.260 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.670 ms
(16 rows)

:explain select * from r1 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.294..0.294 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.011..0.011 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.164 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.535 ms
(12 rows)

:explain select * from r1 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.161..0.161 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.006..0.007 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.170 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.385 ms
(12 rows)

:explain select * from r1 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.496..0.496 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.356..0.356 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
 Planning Time: 0.165 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4115K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.753 ms
(15 rows)

:explain select * from r1 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.494..0.494 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.334..0.334 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
 Planning Time: 0.183 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.751 ms
(15 rows)

-- x2 join y1
:explain select * from t2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.394..0.395 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.265..0.265 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.246 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.726 ms
(15 rows)

:explain select * from t2 a join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=0.650..0.650 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=2 width=24) (actual time=0.296..0.296 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.370 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.066 ms
(16 rows)

:explain select * from t2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=0.484..0.485 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.289..0.290 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.055..0.055 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.054..0.054 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.233 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.706 ms
(19 rows)

:explain select * from t2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.588..0.588 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.244..0.244 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
 Planning Time: 0.241 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.946 ms
(16 rows)

:explain select * from t2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.513..0.514 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.284..0.284 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
 Planning Time: 0.343 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.809 ms
(15 rows)

:explain select * from t2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=0.591..0.591 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.321..0.321 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.383 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.815 ms
(16 rows)

:explain select * from d2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.273..0.273 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.011..0.012 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.126 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.518 ms
(12 rows)

:explain select * from d2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.278..0.278 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.141 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.521 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.264..0.264 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.112 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.494 ms
(12 rows)

:explain select * from d2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.320..0.320 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.010 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.136 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.569 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.274..0.274 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.150 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.505 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.286..0.286 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.174 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.515 ms
(12 rows)

:explain select * from r2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.688..0.688 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.447..0.448 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
 Planning Time: 0.125 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.636 ms
(15 rows)

:explain select * from r2 a join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.702..0.702 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.410..0.410 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
 Planning Time: 0.164 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.589 ms
(16 rows)

:explain select * from r2 a join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.462..0.462 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.287..0.287 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.029..0.030 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.029..0.029 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.129 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.520 ms
(19 rows)

:explain select * from r2 a join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.414..1.415 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.195..1.195 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.914..0.914 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.913..0.913 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.160 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.748 ms
(19 rows)

:explain select * from r2 a join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.611..0.611 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.331..0.331 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.166 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4117K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.601 ms
(15 rows)

:explain select * from r2 a join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.766..0.766 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.468..0.468 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.196 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 11K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.577 ms
(15 rows)

-- x2 join y2
:explain select * from t2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=4.172..4.173 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.08 rows=1 width=28) (actual time=2.733..2.750 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 4:4  (slice3; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.256 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 83.085 ms
(19 rows)

:explain select * from t2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.02..2.10 rows=3 width=24) (actual time=1.489..1.490 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=1 width=24) (actual time=0.012..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.702 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 4 workers, 64K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.590 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.589..0.589 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.486 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 19K bytes avg x 2 workers, 19K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.168 ms
(12 rows)

:explain select * from t2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.355..0.355 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.411 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 23K bytes avg x 2 workers, 23K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.854 ms
(12 rows)

:explain select * from t2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=4.926..4.926 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=1 width=28) (actual time=2.669..2.672 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.497 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 56.419 ms
(19 rows)

:explain select * from t2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=2.318..2.318 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.718..0.718 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.022..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.341 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.412 ms
(16 rows)

:explain select * from d2 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.391..0.391 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.015..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.553 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.039 ms
(12 rows)

:explain select * from d2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.400..0.400 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.274 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.780 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.370..0.371 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.014..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.299 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.871 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.288..0.288 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.352 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.771 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.480..0.480 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.393 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.190 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.344..0.344 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.341 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.892 ms
(12 rows)

:explain select * from r2 a join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=3.342..3.342 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=1 width=28) (actual time=2.820..2.821 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
 Planning Time: 0.520 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 4 workers, 4156K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 54.641 ms
(19 rows)

:explain select * from r2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.686..1.686 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.742..0.743 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
 Planning Time: 0.345 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.263 ms
(16 rows)

:explain select * from r2 a join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.366..0.366 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.025..0.025 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.321 ms
   (slice0)    Executor memory: 32K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.980 ms
(12 rows)

:explain select * from r2 a join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.346..0.346 rows=0 loops=1)
   ->  Hash Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.007..0.007 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.360 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.896 ms
(12 rows)

:explain select * from r2 a join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.259..1.259 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.09 rows=2 width=28) (actual time=0.883..0.883 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.198..0.198 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.197..0.197 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.337 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.293 ms
(19 rows)

:explain select * from r2 a join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=1.989..1.989 rows=0 loops=1)
   ->  Hash Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.234..1.235 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.600..0.600 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.599..0.599 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.237 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.586 ms
(19 rows)

-- x1 left join y1
:explain select * from t1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.417..0.417 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.023..0.023 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.351 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.980 ms
(12 rows)

:explain select * from t1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.352..0.352 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.019..0.019 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.401 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.862 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.358..0.358 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.019..0.019 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.294 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.861 ms
(12 rows)

:explain select * from t1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.336..0.336 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.018..0.018 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.344 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.828 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=0.376..0.376 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.019..0.020 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.406 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.867 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.330..0.330 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.018..0.018 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.455 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.881 ms
(12 rows)

:explain select * from d1 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.997..1.998 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.653..1.654 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.021..1.021 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.040..0.040 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.037 rows=0 loops=1)
 Planning Time: 0.342 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.639 ms
(19 rows)

:explain select * from d1 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.672..1.672 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.255..1.255 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.613..0.613 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.031..0.032 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.030..0.030 rows=0 loops=1)
 Planning Time: 0.190 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.080 ms
(16 rows)

:explain select * from d1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.357..0.357 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.015..0.015 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.316 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.871 ms
(12 rows)

:explain select * from d1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.350..0.350 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.012..0.012 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.202 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.691 ms
(12 rows)

:explain select * from d1 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.684..1.684 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.319..1.319 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.721..0.721 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.249 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.127 ms
(19 rows)

:explain select * from d1 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.808..1.809 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.201..1.202 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.060..0.061 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.601..0.602 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.600..0.600 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
 Planning Time: 0.428 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.325 ms
(19 rows)

:explain select * from r1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.854..0.854 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=28) (actual time=0.003..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.483 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 61K bytes avg x 2 workers, 61K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.840 ms
(12 rows)

:explain select * from r1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=0.818..0.818 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.003..0.004 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.545 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 2 workers, 64K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 51.988 ms
(12 rows)

:explain select * from r1 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=2.342..2.343 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.705..0.705 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
 Planning Time: 0.463 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.974 ms
(13 rows)

:explain select * from r1 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=1.060..1.061 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.682..0.683 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.527 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.627 ms
(13 rows)

:explain select * from r1 a left join r1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.12 rows=4 width=28) (actual time=0.911..0.911 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=28) (actual time=0.004..0.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.521 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 62K bytes avg x 2 workers, 62K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 52.070 ms
(12 rows)

:explain select * from r1 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=4 width=24) (actual time=2.012..2.012 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=2 width=24) (actual time=0.004..0.005 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.615 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 65K bytes avg x 2 workers, 65K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 53.372 ms
(12 rows)

-- x1 left join y2
:explain select * from t1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=1.822..1.823 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.731..0.731 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.025..0.026 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.024..0.025 rows=0 loops=1)
 Planning Time: 0.516 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.591 ms
(15 rows)

:explain select * from t1 a left join t2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.032..1.032 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.08 rows=2 width=24) (actual time=0.684..0.685 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.040..0.040 rows=0 loops=1)
 Planning Time: 0.584 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.773 ms
(16 rows)

:explain select * from t1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=28) (actual time=0.409..0.410 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.022..0.022 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.335 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.962 ms
(12 rows)

:explain select * from t1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=0.292..0.292 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.016..0.016 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.362 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.804 ms
(12 rows)

:explain select * from t1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.881..0.881 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.555..0.555 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
 Planning Time: 0.316 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.241 ms
(15 rows)

:explain select * from t1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.744..0.744 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.437..0.438 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.428 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.192 ms
(16 rows)

:explain select * from d1 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.606..1.606 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.239..1.239 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.755..0.755 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.753..0.754 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.487 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.262 ms
(19 rows)

:explain select * from d1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.219..1.220 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.392..0.392 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.004 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.014..0.014 rows=0 loops=1)
 Planning Time: 0.235 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.754 ms
(16 rows)

:explain select * from d1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.374..0.374 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.011 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.149 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.701 ms
(12 rows)

:explain select * from d1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.256..0.256 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.009..0.009 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.385 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.743 ms
(12 rows)

:explain select * from d1 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=1.501..1.501 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.205..1.206 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.788..0.788 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.787..0.787 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.369 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.170 ms
(19 rows)

:explain select * from d1 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.490..1.490 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=1.199..1.199 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.824..0.824 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.823..0.823 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.387 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 14K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.074 ms
(19 rows)

:explain select * from r1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=28) (actual time=0.637..0.637 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.360..0.361 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
 Planning Time: 0.633 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.178 ms
(15 rows)

:explain select * from r1 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.132..1.132 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.517..0.517 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.594 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.783 ms
(16 rows)

:explain select * from r1 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.13 rows=3 width=28) (actual time=1.191..1.192 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.779..0.780 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.286 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.630 ms
(13 rows)

:explain select * from r1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.14 rows=3 width=24) (actual time=1.010..1.010 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.07 rows=3 width=24) (actual time=0.627..0.628 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.416 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.469 ms
(13 rows)

:explain select * from r1 a left join r2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.15 rows=3 width=28) (actual time=0.951..0.951 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=28) (actual time=0.657..0.657 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.008 rows=0 loops=1)
 Planning Time: 0.386 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.058 ms
(15 rows)

:explain select * from r1 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.316..1.316 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.09 rows=3 width=24) (actual time=0.680..0.680 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.009..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on r1 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.008..0.009 rows=0 loops=1)
 Planning Time: 0.510 ms
   (slice0)    Executor memory: 39K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.208 ms
(15 rows)

-- x2 left join y1
:explain select * from t2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.16 rows=4 width=28) (actual time=2.384..2.384 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=2 width=28) (actual time=0.795..0.796 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:2  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.002 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.007 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.035..0.035 rows=0 loops=1)
 Planning Time: 0.505 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4156K bytes avg x 2 workers, 4156K bytes max.  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 53.587 ms
(19 rows)

:explain select * from t2 a left join t1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.13 rows=3 width=24) (actual time=1.878..1.878 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.08 rows=2 width=24) (actual time=1.387..1.387 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.748..0.748 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.747..0.747 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.288 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.304 ms
(16 rows)

:explain select * from t2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.008..1.008 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.690..0.690 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.286 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.065 ms
(19 rows)

:explain select * from t2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.001..1.001 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.625..0.625 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.016..0.017 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.420 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.571 ms
(16 rows)

:explain select * from t2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.16 rows=4 width=28) (actual time=2.347..2.347 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=28) (actual time=0.948..0.949 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:2  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.005 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.348..0.349 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.348..0.348 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
 Planning Time: 0.429 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 2 workers, 4157K bytes max.  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 2 workers, 51K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 64.322 ms
(19 rows)

:explain select * from t2 a left join r1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.239..1.240 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.664..0.665 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.017..0.018 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
 Planning Time: 0.712 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.636 ms
(16 rows)

:explain select * from d2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=2.198..2.198 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.112..1.113 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.433..0.433 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.033..0.033 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.011..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
 Planning Time: 0.408 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.875 ms
(19 rows)

:explain select * from d2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=1.684..1.684 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=1.337..1.337 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.753..0.753 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.024..0.024 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.023..0.023 rows=0 loops=1)
 Planning Time: 0.241 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.156 ms
(16 rows)

:explain select * from d2 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.208..0.208 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.010..0.010 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.009..0.009 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.318 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.721 ms
(12 rows)

:explain select * from d2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.198..0.198 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.390 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.678 ms
(12 rows)

:explain select * from d2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.541..1.541 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.303..1.304 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.946..0.946 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.946..0.946 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.195 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.851 ms
(19 rows)

:explain select * from d2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=0.595..0.595 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=0.421..0.422 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.100..0.100 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.007 rows=0 loops=1)
 Planning Time: 0.272 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.055 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.594..0.594 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.415..0.415 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.184..0.184 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
 Planning Time: 0.385 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.286 ms
(19 rows)

:explain select * from r2 a left join t1 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.02..2.16 rows=3 width=24) (actual time=0.568..0.568 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.10 rows=3 width=24) (actual time=0.398..0.398 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.178..0.178 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.302 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.002 ms
(16 rows)

:explain select * from r2 a left join d1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=28) (actual time=0.584..0.585 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=0.387..0.387 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.147..0.147 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.147..0.147 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.017..0.017 rows=0 loops=1)
 Planning Time: 0.196 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.990 ms
(19 rows)

:explain select * from r2 a left join d1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=0.550..0.550 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.12 rows=3 width=24) (actual time=0.358..0.358 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.128..0.128 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
 Planning Time: 0.227 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.988 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.17 rows=3 width=28) (actual time=1.371..1.372 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=28) (actual time=1.198..1.198 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.979..0.979 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.978..0.978 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.397 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 12K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.010 ms
(19 rows)

:explain select * from r2 a left join r1 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.04..2.18 rows=3 width=24) (actual time=1.396..1.396 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.11 rows=3 width=24) (actual time=1.216..1.217 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.013 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.985..0.985 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.984..0.984 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
 Planning Time: 0.559 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4120K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 13K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.058 ms
(19 rows)

-- x2 left join y2
:explain select * from t2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=5.774..5.774 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.08 rows=1 width=28) (actual time=4.965..4.969 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.001..0.001 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.011..0.012 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 4:4  (slice3; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.010..0.010 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Parallel Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.007..0.008 rows=0 loops=1)
 Planning Time: 0.315 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 4 workers, 4157K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 51K bytes avg x 4 workers, 51K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 69.108 ms
(19 rows)

:explain select * from t2 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.02..2.10 rows=3 width=24) (actual time=1.876..1.877 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.05 rows=1 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.002..0.003 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.716 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 64K bytes avg x 4 workers, 64K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 53.022 ms
(12 rows)

:explain select * from t2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=1.610..1.610 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.741..0.742 rows=0 loops=1)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.021..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.496 ms
   (slice0)    Executor memory: 31K bytes.
   (slice1)    Executor memory: 4114K bytes avg x 2 workers, 4114K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.226 ms
(13 rows)

:explain select * from t2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=1.336..1.336 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.743..0.744 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
 Planning Time: 0.624 ms
   (slice0)    Executor memory: 35K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.054 ms
(13 rows)

:explain select * from t2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 4:1  (slice1; segments: 4)  (cost=1.04..2.13 rows=3 width=28) (actual time=5.070..5.070 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=1 width=28) (actual time=4.528..4.533 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 4:4  (slice2; segments: 4)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.005..0.006 rows=0 loops=1)
               Hash Key: a.c1
               ->  Parallel Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.037..0.037 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.012..0.014 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:4  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.011..0.012 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
 Planning Time: 0.680 ms
   (slice0)    Executor memory: 41K bytes.
   (slice1)    Executor memory: 4157K bytes avg x 4 workers, 4157K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 50K bytes avg x 4 workers, 50K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 56.878 ms
(19 rows)

:explain select * from t2 a left join r2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.681..1.681 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.738..0.738 rows=0 loops=1)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.020..0.020 rows=0 loops=1)
 Planning Time: 0.618 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.000 ms
(16 rows)

:explain select * from d2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.735..1.736 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.353..1.353 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.047..0.048 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.644..0.645 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.644..0.644 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.540 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.528 ms
(19 rows)

:explain select * from d2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.019..1.019 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=0.676..0.677 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.019..0.019 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.018..0.018 rows=0 loops=1)
 Planning Time: 0.581 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.723 ms
(16 rows)

:explain select * from d2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.07..2.07 rows=3 width=28) (actual time=0.513..0.513 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.07 rows=3 width=28) (actual time=0.018..0.019 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.322 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.067 ms
(12 rows)

:explain select * from d2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.08..2.08 rows=3 width=24) (actual time=0.353..0.354 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=3 width=24) (actual time=0.013..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.011..0.011 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.159 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.666 ms
(12 rows)

:explain select * from d2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.209..2.210 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.849..1.849 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.231..1.232 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.230..1.230 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.015..0.015 rows=0 loops=1)
 Planning Time: 0.141 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.632 ms
(19 rows)

:explain select * from d2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=1.703..1.703 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.364..1.365 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.016..0.016 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.801..0.802 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.801..0.801 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.026..0.026 rows=0 loops=1)
 Planning Time: 0.201 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.213 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=1.748..1.748 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=1.004..1.004 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.004 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=0.199..0.200 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.198..0.198 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.019..0.020 rows=0 loops=1)
 Planning Time: 0.508 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.619 ms
(19 rows)

:explain select * from r2 a left join t2 b using (c1, c2);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.13 rows=3 width=24) (actual time=1.731..1.731 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.08 rows=2 width=24) (actual time=1.327..1.327 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.606..0.607 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (actual time=0.021..0.022 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Seq Scan on t2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.021..0.021 rows=0 loops=1)
 Planning Time: 0.518 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 14K bytes avg x 2 workers, 14K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.422 ms
(16 rows)

:explain select * from r2 a left join d2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.10 rows=3 width=28) (actual time=0.377..0.377 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.05 rows=2 width=28) (actual time=0.008..0.008 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.006..0.006 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.289 ms
   (slice0)    Executor memory: 33K bytes.
   (slice1)    Executor memory: 21K bytes avg x 2 workers, 21K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.924 ms
(12 rows)

:explain select * from r2 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.02..2.11 rows=3 width=24) (actual time=0.349..0.349 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.02..2.06 rows=2 width=24) (actual time=0.006..0.006 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.004..0.005 rows=0 loops=1)
         ->  Hash  (cost=1.01..1.01 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.01 rows=1 width=16) (never executed)
 Planning Time: 0.343 ms
   (slice0)    Executor memory: 36K bytes.
   (slice1)    Executor memory: 24K bytes avg x 2 workers, 24K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 0.877 ms
(12 rows)

:explain select * from r2 a left join r2 b using (c1);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.14 rows=3 width=28) (actual time=2.316..2.316 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.09 rows=2 width=28) (actual time=2.000..2.000 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.002..0.002 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.498..1.499 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.498..1.498 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.013..0.014 rows=0 loops=1)
 Planning Time: 0.294 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4116K bytes avg x 2 workers, 4116K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.028 ms
(19 rows)

:explain select * from r2 a left join r2 b using (c1, c2);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.04..2.15 rows=3 width=24) (actual time=1.762..1.762 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.04..2.10 rows=2 width=24) (actual time=1.449..1.449 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=0.003..0.003 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.012 rows=0 loops=1)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (actual time=1.029..1.029 rows=0 loops=1)
               Buckets: 524288  Batches: 1  Memory Usage: 4096kB
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..1.03 rows=1 width=16) (actual time=1.028..1.028 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..1.01 rows=1 width=16) (actual time=0.012..0.013 rows=0 loops=1)
 Planning Time: 0.395 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4120K bytes avg x 2 workers, 4120K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
   (slice3)    Executor memory: 15K bytes avg x 2 workers, 15K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.449 ms
(19 rows)

--
-- insert
--
insert into t1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  5 |   
  6 |   
  3 |   
  4 |   
(6 rows)

begin;
insert into t1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into t2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

rollback;
begin;
insert into t1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into t2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
 10 |   
 11 |   
 12 |   
 14 |   
 15 |   
 16 |   
 18 |   
 19 |   
 20 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 13 |   
 17 |   
(20 rows)

insert into d2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  6 |   
 10 |   
 13 |   
 18 |   
 20 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  7 |   
  8 |   
  9 |   
 11 |   
 12 |   
 14 |   
 15 |   
 16 |   
 17 |   
 19 |   
(20 rows)

rollback;
begin;
insert into t1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(12 rows)

insert into t1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  1 |   
  2 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into t2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  5
    |  2
    |  3
    |  4
    |  6
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  1 |   
  2 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(30 rows)

insert into d1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  1 |   
  2 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(24 rows)

insert into d2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  1 |   
  2 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(42 rows)

insert into r1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  1 |   
  2 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  4 |   
  5 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  6
    |  2
    |  3
    |  4
    |  5
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  1 |   
  2 |   
  3 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  4 |   
  6 |   
  2 |   
  3 |   
  5 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  2 |   
  3 |   
  6 |   
    |  2
    |  3
    |  4
    |  5
  1 |   
  2 |   
  3 |   
  5 |   
  6 |   
  1 |   
  4 |   
  6 |   
  1 |   
  2 |   
  1 |   
  2 |   
  5 |   
  6 |   
  1 |   
  4 |   
  5 |   
    |  1
    |  6
  4 |   
  2 |   
  3 |   
  5 |   
  3 |   
  4 |   
  5 |   
  6 |   
(36 rows)

rollback;
--
-- pg_relation_size() dispatches an internal query, to fetch the relation's
-- size on each segment. The internal query doesn't need to be part of the
-- distributed transactin. Test that we correctly issue two-phase commit in
-- those segments that are affected by the INSERT, and that we don't try
-- to perform distributed commit on the other segments.
--
insert into r1 (c4) values (pg_relation_size('r2'));
--
-- copy to a partial replicated table from file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_from (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

copy partial_rpt_from (c1, c2) from stdin with delimiter ',';
select * from gp_dist_random('partial_rpt_from');
 c1 | c2 
----+----
  1 |  2
  1 |  2
(2 rows)

--
-- copy from a partial replicated table to file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_to (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into partial_rpt_to values (1,1);
copy partial_rpt_to to stdout;
1	1
-- change a replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- change to another replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- start_ignore
-- We need to do a cluster expansion which will check if there are partial
-- tables, we need to drop the partial tables to keep the cluster expansion
-- run correctly.
reset search_path;
drop schema test_partial_table cascade;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table test_partial_table.t1
drop cascades to table test_partial_table.d1
drop cascades to table test_partial_table.r1
drop cascades to table test_partial_table.t2
drop cascades to table test_partial_table.d2
drop cascades to table test_partial_table.r2
drop cascades to table test_partial_table.size_sanity_check
drop cascades to table test_partial_table.partial_rpt_from
drop cascades to table test_partial_table.partial_rpt_to
-- end_ignore
